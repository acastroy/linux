/*
 *  TW5864 driver - analog decoders configuration functions
 *
 *  Copyright (C) 2015 Bluecherry, LLC <maintainers@bluecherrydvr.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 */

#include "tw5864.h"
#include "tw5864-reg.h"

/* Data written to registers */
static const u8 tbl_pal_tw2864_common[] = {
	0x00, 0x00, 0x64, 0x11, 0x80, 0x80, 0x00, 0x12,
	0x12, 0x20, 0x0a, 0xd0, 0x00, 0x00, 0x07, 0x7f,
};

static const u8 tbl_ntsc_tw2864_common[] = {
	0x00, 0x00, 0x64, 0x11, 0x80, 0x80, 0x00, 0x02,
	0x12, 0xf0, 0x0c, 0xd0, 0x00, 0x00, 0x07, 0x7f,
};

static const u8 tbl_pal_tw2864_common2[] = {
	0x00, 0x22, 0x00, 0x00, 0x22, 0x00, 0x00, 0x22,
	0x00, 0x00, 0x22, 0x00,
};

static const u8 tbl_pal_tw2865_common[] = {
	0x00, 0x00, 0x64, 0x11, 0x80, 0x80, 0x00, 0x12,
	0x17, 0x20, 0x0c, 0xd0, 0x00, 0x00, 0x07, 0x7f,
};

static const u8 tbl_ntsc_tw2865_common[] = {
	0x00, 0x00, 0x64, 0x11, 0x80, 0x80, 0x00, 0x02,
	0x12, 0xf0, 0x0c, 0xd0, 0x00, 0x00, 0x07, 0x7f,
};

static const u8 audio_tw2865_common[] = {
	0x33, 0x33, 0x03, 0x31, 0x75, 0xb9, 0xfd, 0x20,
	0x64, 0xa8, 0xec, 0xc1, 0x00, 0x00, 0x00, 0x80,
	0x00, 0xc0, 0xaa, 0xaa,
};

static const u8 audio_tbl_pal_tw2865_8KHz[] = {
	0x83, 0xb5, 0x09, 0x00, 0xa0, 0x00,
};

static const u8 audio_tbl_pal_tw2865_16KHz[] = {
	0x07, 0x6b, 0x13, 0x00, 0x40, 0x01,
};

static const u8 audio_tbl_ntsc_tw2865_8KHz[] = {
	0x83, 0xb5, 0x09, 0x78, 0x85, 0x00,
};

static const u8 audio_tbl_ntsc_tw2865_16KHz[] = {
	0x07, 0x6b, 0x13, 0xef, 0x0a, 0x01,
};

/* Format used for tw_i2c_scatter_write(): (addr) (value) */
static const u8 tbl_tw2864_other[] = {
	0x89, 0x02,
	0x94, 0x14,
	0x9c, 0x20,
	0x9e, 0x72,
	0x9e, 0x7a,
	0x9f, 0x00,
	0xaa, 0x00,
	0xb1, 0x2a,
	0xca, 0xaa,
	0xcb, 0x00,
	0xcf, 0x83,
	0xcf, 0x83,
	0xd2, 0x01,
	0xdb, 0xc1,
	0xdd, 0x00,
	0xde, 0x00,
	0xe0, 0x00,
	0xe1, 0xc0,
	0xe2, 0xaa,
	0xe3, 0xaa,
	0xf8, 0x64,
	0xf9, 0x11,
	0xfa, 0xc6,
	0xfb, 0x6f,
	0xfc, 0xff,
};

static const u8 tbl_tw2865_other1[] = {
	0x18, 0x19,
	0x1a, 0x06,
	0x28, 0x19,
	0x2a, 0x06,
	0x38, 0x19,
	0x3a, 0x06,
	0x41, 0xd4,
	0x43, 0x08,
	0x60, 0x15,
	0x61, 0x02,
	0x6b, 0x0f,
	0x6c, 0x0f,
	0x96, 0xe6,
	0x97, 0xc3,
	0x9c, 0x20,
	0x9e, 0x72,
	0x9e, 0x7a,
	0x9f, 0x03,
	0xaa, 0x00,
	0xb1, 0x2a,
	0xca, 0x02,
	0xf9, 0x51,
	0xfa, 0x4a,
	0xfb, 0x6f,
	0xfc, 0xff,
};

static const u8 tbl_tw2866_other1[] = {
	0x08, 0x19,
	0x0a, 0x06,
	0x18, 0x19,
	0x1a, 0x06,
	0x28, 0x19,
	0x2a, 0x06,
	0x38, 0x19,
	0x3a, 0x06,
	0x41, 0xd4,
	0x43, 0x08,
	0x5b, 0xff,
	0x60, 0x15,
	0x61, 0x02,
	0x6b, 0x0f,
	0x6c, 0x0f,
	0x96, 0xe6,
	0x97, 0xc3,
	0x9c, 0x20,
	0x9e, 0x72,
	0x9e, 0x7a,
	0x9f, 0x00,
	0xaa, 0x00,
	0xb1, 0x2a,
	0xca, 0x02,
	0xf9, 0x51,
	0xfa, 0x4a,
	0xfb, 0x6f,
	0xfc, 0xff,
};

static const u8 tbl_tw2865_other2[] = {
	0x70, 0x08,
	0x73, 0x01,
	0x7f, 0x80,
	0xcf, 0x80,
	0xf8, 0xc4,
	0xf9, 0x51,
};

static const u8 tbl_tw2865_other3[] = {
	0x7e, 0xc0,
	0x89, 0x05,
	0xe0, 0x00,
};

static int tw28xx_clkp_delay(struct tw5864_dev *dev, u8 i2c_index)
{
	int base_chan = i2c_index * 4;
	int delay;
	u8 flags = 0;

	tw_i2c_read(i2c_index, 0x9f, &flags);
	for (delay = 0; delay < 16; delay++) {
		tw_i2c_write(i2c_index, 0x9f, delay);
		tw_writel(TW5864_H264EN_BUS0_MAP, base_chan);
		/* clear error flags */
		tw_writel(TW5864_UNDECLARED_ERROR_FLAGS_0x9218, 0x1);
		mdelay(100);
		if (tw_readl(TW5864_UNDECLARED_ERROR_FLAGS_0x9218) == 0)
			break;
	}
	tw_i2c_write(i2c_index, 0x9f, flags);

	if (delay >= 16) {
		dev_err(&dev->pci->dev,
			"Cannot find suitable clkp_del for i2c_index 0x%02x\n",
			i2c_index);
		return -EFAULT;
	}

	dev_dbg(&dev->pci->dev, "Auto detect CLKP_DEL = %02x\n", delay);
	return 0;
}

static int init_tw2864(struct tw5864_dev *dev, u8 i2c_index)
{
	u32 ch;
	int ret = 0;

	for (ch = 0; ch < 4; ch++)
		ret |= tw_i2c_multi_write(i2c_index, ch * 0x10,
					  tbl_pal_tw2864_common,
					  sizeof(tbl_pal_tw2864_common));

	ret |= tw_i2c_scatter_write(i2c_index, tbl_tw2864_other,
				    sizeof(tbl_tw2864_other) / 2);

	if (ret)
		return ret;

	return tw28xx_clkp_delay(dev, i2c_index);
}

static int init_tw2865(struct tw5864_dev *dev, u8 i2c_index)
{
	u32 ch;
	int ret = 0;

	for (ch = 0; ch < 4; ch++) {
		ret |= tw_i2c_multi_write(i2c_index, ch * 0x10,
					  tbl_pal_tw2865_common,
					  sizeof(tbl_pal_tw2865_common));
	}

	ret |= tw_i2c_scatter_write(i2c_index, tbl_tw2865_other1,
				    sizeof(tbl_tw2865_other1) / 2);
	ret |= tw_i2c_multi_write(i2c_index, 0xd0, audio_tw2865_common,
				  sizeof(audio_tw2865_common));
	ret |= tw_i2c_scatter_write(i2c_index, tbl_tw2865_other2,
				    sizeof(tbl_tw2865_other2) / 2);
	ret |= tw_i2c_multi_write(i2c_index, 0xf0, audio_tbl_pal_tw2865_8KHz,
				  sizeof(audio_tbl_pal_tw2865_8KHz));
	ret |= tw_i2c_scatter_write(i2c_index, tbl_tw2865_other3,
				    sizeof(tbl_tw2865_other3) / 2);
	ret |= tw_i2c_write(i2c_index, 0xe0, 0x10);

	return ret;
}

int tw5864_tw28xx_init(struct tw5864_dev *dev)
{
	int i;
	int ret;

	for (i = 1; i < 4; i++) {
		ret = init_tw2864(dev, i);
		if (ret)
			return ret;
	}
	return init_tw2865(dev, 0);
}
